#!/usr/bin/env python 
import web, json, sys, exceptions, re, datetime, urllib
from amazon_ses import AmazonSES, EmailMessage, AmazonError
from twilio.rest import TwilioRestClient
from decimal import Decimal
from psycopg2 import ProgrammingError, DataError, IntegrityError
from dbconnect import dbconnect, twilio, amazon_ses
from orderedDict import OrderedDict
from lxml import etree

urls = (
  "/(.+)/(.+)", "getservice",
  "/(.+)/", "getservices",
  "/manager", "manager",
  "/", "getschemas"
  )

class DopaServicesError(Exception):
    """Exception Class that allows the DOPA Services REST Server to raise custom exceptions"""
    pass  

class CustomJSONEncoder(json.JSONEncoder):
    """Class to provide the correct serialisation of decimal values into JSON"""
    def default(self, obj):
        if isinstance(obj, Decimal):
            return float(obj)
        elif isinstance(obj, datetime.date):
            return obj.strftime("%d/%m/%Y %H:%M:%S")
        return json.JSONEncoder.default(self, obj)

class getschemas:
    def GET(self):
        try:
            render = web.template.render('templates/')
            conn = dbconnect("species_appuser")
            conn.cur.callproc("utils.dopa_rest_getschemas")
            schemas = conn.cur.fetchall()
            schemasdict = [dict([('name', schema[0]), ('description', schema[1])]) for schema in schemas]
            return render.getschemas(schemasdict, render.header(), render.footer())
        
        except (DopaServicesError, ProgrammingError):
            return "DOPA Services Error: " + str(sys.exc_info())

class getservices:
    def GET(self, schemaname):
        try:
            render = web.template.render('templates/')
            conn = dbconnect("species_appuser")
            conn.cur.callproc("utils.dopa_rest_getservices", [schemaname])
            services = conn.cur.fetchall()
            servicesdict = [dict([('name', service[0]), ('description', getservicedescription(service[1]))]) for service in services if isAuthorised(service[0])]
            return render.getservices(schemaname, servicesdict, render.header(), render.footer())

        except (DopaServicesError, ProgrammingError):
            return "DOPA Services Error: " + str(sys.exc_info())

class getservice:
    def GET(self, schemaname, servicename):
        # if there are some parameters then the user is calling the service
        if web.input():
            return callservice(schemaname, servicename, web.ctx.query[1:])  # pass the querystring to preserve the order of the parameters - the web.input() collection does not preserve the order
        else:
            try:
                render = web.template.render('templates/')
                conn = dbconnect("species_appuser")
                conn.cur.callproc("utils.dopa_rest_getservice", [servicename])
                params = conn.cur.fetchall()
                if (len(params) == 0):
                    raise DopaServicesError('No parameters found for service ' + servicename)
                
                # parse the description text to get the parameters descriptions - the parameter descriptions are encoded using {<param_desc>$<param_desc>$<param_desc> etc}
                paramdesc = []
                paramdescgroups = re.search('{.*}', params[0][1])
                if (paramdescgroups):
                    paramdesc = paramdescgroups.group(0)[1:-1].split("$")
                # fill in the parameter descriptions if they have not been written
                paramdesc[len(paramdesc):] = ['No description' for i in range(len(params) - len(paramdesc))] 
                
                # parse the function definition for default parameter values
                paramdefs = []
                paramdefsstr = params[0][5]
                if 'DEFAULT ' in paramdefsstr:
                    # get the position of the parameter names in the parameter definition string
                    pos = [paramdefsstr.find(param[3] + ' ') for param in params if (param[2] == 'IN')]
                    # add on the length of the parameter definition to get the last parameter definition
                    pos.append(len(paramdefsstr))
                    # get the parameter definitions as a list
                    paramdefs = [paramdefsstr[pos[i]:pos[i + 1]] for i in range(len(pos) - 1)]
                    # remove any trailing spaces with commas
                    paramdefs = [(p[:-2] if p[-2:] == ', ' else p) for p in paramdefs]
                    # remove the DEFAULT statement
                    paramdefs = [(p[p.find('DEFAULT') + 8:] if 'DEFAULT' in p else '') for p in paramdefs]
                    # remove the  ARRAY[] statement
                    paramdefs = [(p[6:-1] if 'ARRAY' in p else p) for p in paramdefs]
                    # remove any typecast symbols, e.g. ::text
#                    paramdefs = [p[:p.find('::')] if '::' in p else p for p in paramdefs] # some are complicated, e.g. ['wdpa_id integer, ', "rlstatus character[] DEFAULT ARRAY['EN'::text, 'CR'::text, 'VU'::text, 'NT'::text, 'LC'::text, 'EX'::text, 'EW'::text, 'DD'::text]"]
                    paramdefs = [p.replace("::text", "") for p in paramdefs]
                    paramdefs = [p.replace("::integer", "") for p in paramdefs]
                    paramdefs = [p.replace("::character varying", "") for p in paramdefs]
                    # remove any quotes, e.g. 'CR','DD' -> CR, DD
                    paramdefs = [p.replace("'", "") for p in paramdefs]
                    # remove any spaces, e.g. CR, DD -> CR,DD
                    paramdefs = [p.replace(" ", "") for p in paramdefs]
                # fill in the paramdefs
                paramdefs[len(paramdefs):] = ['' for i in range(len(params) - len(paramdefs))]
#                return params
                # create a dictionary containing the parameter information
                paramsdict = [dict([('mode', params[i][2]), ('name', params[i][3]), ('type', gettypefrompostgresql(params[i][4])), ('description', paramdesc[i]), ('default', paramdefs[i])]) for i in range(len(params))]
                return render.getservice(schemaname, servicename, getservicedescription(params[0][1]), [p for p in paramsdict if (p['mode'] == 'IN')], [p for p in paramsdict if (p['mode'] == 'OUT')], render.header(), render.footer())
            
            except (DopaServicesError):
                return "DOPA Services Error: " + str(sys.exc_info())

def callservice(schemaname, servicename, querystring):
    try:
        t1 = datetime.datetime.now()
            
        # PARSE THE STANDARD OPTIONAL INPUT PARAMETERS
        # get the input parameters
        params = OrderedDict([(q.split("=")[0], urllib.unquote(q.split("=")[1])) for q in querystring.split("&")])  # the unquoting is to handle encoded parameters (like from extJS - 1,2,3 as a parameter becomes 1%2C2%2C3
        # get the standard optional parameters from the url 
        format = params.setdefault('format', 'json') 
        fields = params.setdefault('fields', '').split(",")  # fields will be passed as an array, e.g. iucn_species_id,wdpa_id
        callback = params.setdefault('callback', None)
        includemetadata = params.setdefault('includemetadata', 'true')
        metadataName = params.setdefault('metadataname', 'metadata')
        rootName = params.setdefault('rootname', 'records')
        parseparams = params.setdefault('parseparams', 'true')
        # remove the standard optional parameters from the dictionary so we are left with just the parameters required for the function
        del (params['format'], params['fields'], params['callback'], params['includemetadata'], params['parseparams'], params['metadataname'], params['rootname'])

        # PARSE AND CONVERT THE DATA TYPES OF THE OTHER INPUT PARAMETERS
        conn = dbconnect("species_especies_schema")
        # get the parameters for the function from postgresql
        conn.cur.callproc('utils.dopa_rest_getparams', [servicename])
        # get the function parameters as a string and split this into a list, e.g. wdpa_id integer, presence_id integer[] -->  ['wdpa_id integer', ' presence_id integer[]']
        functionparams = conn.cur.fetchone()
        hasparams = True if functionparams[0] else False
        if hasparams:
            functionparams = functionparams[0].split(',')  
            # get the names of the function parameters which are array types
            arrayparamnames = [p.strip().split(" ")[0] for p in functionparams if '[' in p]
            # convert the array values into lists
            for key in params.keys():
                if key in arrayparamnames:
                    strlist = params[key].split(",")
                    isnum = isNumeric(strlist[0])
                    if isnum:
                        params[key] = [int(s) for s in strlist]
                    else:
                        params[key] = strlist
            # get the full list of function parameter names
            functionparamnames = [p.strip().split(" ")[0] for p in functionparams]
            # check that all parameters are correct
            invalidparamnames = [n for n in params.keys() if n not in functionparamnames]
            if invalidparamnames and parseparams == 'true':
                raise DopaServicesError('Invalid parameters: ' + ",".join(invalidparamnames))
            # put the input parameters in the right order 
            params = OrderedDict([(n, params[n]) for n in functionparamnames if n in params.keys()])
        
        # AUTHORISE THE SERVICE BASED ON ITS NAME
        if not (isAuthorised(servicename)):
            raise DopaServicesError('Unauthorised servicename')     

        # RUN THE QUERY
        if hasparams & len(functionparams) != len(params):  # not all parameters are being passed to the function - so we need to use named parameters
            sql = "SELECT * from " + schemaname + "." + servicename + "(" + ",".join([n + ":=%(" + n + ")s" for n in params]) + ");"  # run the query using named parameters
#            return 'sql: ' + sql + ' params: ' + str(params) + ' query: ' + conn.cur.mogrify(sql, params)
            conn.cur.execute(sql, params)
        else:
            conn.cur.callproc(schemaname + "." + servicename, params.values())  # run the query using positional parameters
        t2 = datetime.datetime.now()
        rows = conn.cur.fetchall()
        conn.cur.close()
        
        # METADATA SECTION OF RESPONSE
        allfields = [d.name for d in conn.cur.description]
        fieldcount = len(allfields)
        if (fields == ['']): fields = allfields 
#        return conn.cur.description
        fieldsdict = [dict([("name", d.name), ("type", gettypefromtypecode(d.type_code))]) for d in conn.cur.description if (d.name in fields)]
        if len(fieldsdict) != len(fields):
            raise DopaServicesError('Invalid output fields')
        metadatadict = OrderedDict([("duration", str(t2 - t1)), ("error", None), ("idProperty", conn.cur.description[0].name), ("successProperty", 'success'), ("totalProperty", 'recordCount'), ("success", True), ("recordCount", int(conn.cur.rowcount)), ("root", rootName), ("fields", fieldsdict)])    
        
        # RECORDS SECTION OF THE RESPONSE
        colsRequired = [allfields.index(field) for field in fields]
        if format in ['json', 'array']:
            if format == 'json':
                recordsdict = [OrderedDict([(allfields[col], row[col]) for col in range(fieldcount) if (col in colsRequired)]) for row in rows] 
            else:
                recordsdict = [[row[col] for col in range(fieldcount) if (col in colsRequired)] for row in rows]
            json.encoder.FLOAT_REPR = lambda f: ("%.4f" % f)  # this specifies how many decimal places are returned in the json with float values - currently set to 4
            if (includemetadata.lower() == 'true'):
                responsejson = json.dumps(dict([(metadataName, metadatadict), (rootName, recordsdict)]), indent=1, cls=CustomJSONEncoder)
            else: 
                responsejson = json.dumps(dict([(rootName, recordsdict)]), indent=1, cls=CustomJSONEncoder)
            if callback:
                web.header("Content-Type", "application/javascript") 
                return callback + '(' + responsejson + ');'                 
            else:
                web.header("Content-Type", "application/json") 
                return responsejson
        
        elif format == 'xml':
            root = etree.Element('results')
        #            THERE ARE ISSUES WITH THE XML SERIALISER PARSING INTEGERS AND IN THE FIELD TYPES THERE ARE INTEGERS SO THE METADATADICT OBJECT CAUSES THE XML PARSER TO FAIL AT THE MOMENT SO LEAVING OUT METADATA
        #            if (includemetadata.lower() == 'true'):
        #                return metadatadict
        #                metadatanode = xml.Element('metadata', metadatadict)
        #                root.append(metadatanode)
        #                xmlfieldsdicts = [dict([("name", d.name), ("type", str(d.type_code))]) for d in conn.cur.description if (d.name in fields)] # element tree cannot serialise integers so we have to convert these to strings
        #                fieldselements = [xml.Element('field', dictionary) for dictionary in xmlfieldsdicts]
        #                fieldsnode = xml.Element('fields')
        #                for fieldelement in fieldselements:
        #                    fieldsnode.append(fieldelement)
        #                metadatanode.append(fieldsnode)
            recordsdicts = [OrderedDict([(allfields[col], str(row[col]).decode('utf-8')) for col in range(fieldcount) if (col in colsRequired) and str(row[col]) != 'None']) for row in rows ]  #
            recordselements = [etree.Element('record', element) for element in recordsdicts]
            recordsnode = etree.Element(rootName)
            for recordelement in recordselements:
                recordsnode.append(recordelement)
            root.append(recordsnode)
            web.header("Content-Type", "text/xml")
            return etree.tostring(root)
        
        elif format == 'sms':
            _twilio = twilio()
            client = TwilioRestClient(_twilio.twilio_account_sid, _twilio.twilio_auth_token)  # use the twilio api account
            bodystr = 'Hi Andrew - test species data: '
            bodystr = bodystr + str(rows[0])[:160 - len(bodystr)]
            message = client.sms.messages.create(to="+393668084920", from_="+19712647662", body=bodystr)  # my mobile
            return message

        elif format == 'email':
            _amazon_ses = amazon_ses()
            amazonSes = AmazonSES(_amazon_ses.AccessKeyID, _amazon_ses.SecretAccessKey)  # use the amazon simple email service api account
            message = EmailMessage()
            message.subject = 'DOPA Information Request'
            data = [[row[col] for col in range(fieldcount) if (col in colsRequired)] for row in rows]
            colnames = "<tr>" + "".join(["<th>" + f["name"] + "</th>" for f in metadatadict["fields"]]) + "</tr>"
            message.bodyHtml = "Results for the query : " + querystring + "<table>" + colnames + "".join(["<tr>" + p + "</tr>" for p in ["".join(h) for h in [['<td>' + str(col) + '</td>' for col in row] for row in data]]]) + "</table>"
            result = amazonSes.sendEmail('a.cottam@gmail.com', 'a.cottam@gmail.com', message)  # to me
            return result 
                    
        else:
            raise DopaServicesError('Invalid response format: ' + format)

    except (DopaServicesError, DataError, ProgrammingError, exceptions.TypeError, IndexError, IntegrityError, AmazonError) as e:
#        web.webapi.internalerror() #returns a internal server error 500
        t2 = datetime.datetime.now()
        msg = "There was an error sending the email. Make sure that the email address has been verified in Amazon Simple Email Services" if type(e) == AmazonError else str(sys.exc_info()).decode('string_escape')
        if format in ['json', 'array']:
            metadatadict = OrderedDict([("duration", str(t2 - t1)), ("error", msg), ("idProperty", None), ("successProperty", 'success'), ("totalProperty", 'recordCount'), ("success", False), ("recordCount", 0), ("root", None), ("fields", None)])    
            responsejson = json.dumps(dict([(metadataName, metadatadict), (rootName, None)]), indent=1)
            if callback:
                web.header("Content-Type", "application/javascript") 
                return callback + '(' + responsejson + ');'                 
            else:
                web.header("Content-Type", "application/json") 
                return responsejson

        else:
            return "DOPA Services Error: " + msg
            
def gettypefromtypecode(typecode):  # returns a string representation of the psycopg2.cursor.type_code value which is shown in the response - the values come from the pg_type table in PostGIS and these are not complete yet - in the output parameter data type section
    if (typecode in [16, 1000, 1560, 1561]): return "boolean"
    elif (typecode in [20, 21, 23]): return "integer"
    elif (typecode in [26, 790, 1005, 1007, 1028, 1016, 1021, 1022, 1700]): return "number"
    elif (typecode in [700, 701]): return "float"
    elif (typecode in [18, 25, 1043, 1002, 1009, 1015, 1043]): return "string"
    elif (typecode in [702, 703, 704, 1023, 1024, 1025, 1082, 1083, 1084, 1182, 1183, 1184, ]): return "date"
    elif (typecode in [17, 22, 24, 27, 28, 29, 30]): return "object"
    elif (typecode in [2278]): return "Null"
    else: return "Undefined"
    
def gettypefrompostgresql(postgresqltype):  # returns a string representation of the SQL data type - this is used to show the data type in the html pages
    if (postgresqltype.lower() in ['integer', 'bigint']): return "integer"
    elif (postgresqltype.lower() in ['boolean']): return "boolean"
    elif (postgresqltype.lower() in ['single precision']): return "single"
    elif (postgresqltype.lower() in ['double precision']): return "double"
    elif (postgresqltype.lower() in ['array']): return "array"
    elif (postgresqltype.lower() in ['character varying', 'text']): return "string"
    elif (postgresqltype.lower() in ['date']): return "date"
    elif (postgresqltype.lower() in ['timestamp with time zone']): return "datetime"
    else: return "unknown"

def getservicedescription(fulldescription):
    pos = fulldescription.find("{")
    if pos > -1:
        return fulldescription[:fulldescription.find("{")]
    else:
        return fulldescription

def isNumeric(val):
    try:
        i = float(val)
    except ValueError, TypeError:
        return False
    else:
        return True

def isAuthorised(servicename):
    if (servicename[:3] in ['get', 'set']) | ((servicename[:1] == '_') & (web.ctx.host == 'dopa-services.jrc.it')):
        return True
    else:
        return False

class manager:
    def GET(self):
        try:
            render = web.template.render('templates/')
            conn = dbconnect("species_appuser")
            conn.cur.execute("select * from especies.species_wdpa_log")
            rows = conn.cur.fetchall()
            return render.manager(rows, render.header_manager(), render.footer_manager())
        
        except (DopaServicesError, ProgrammingError):
            return "DOPA Services Error: " + str(sys.exc_info())
        
if __name__ == "__main__":
     app = web.application(urls, globals()).run()
